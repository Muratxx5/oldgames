<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Modern Tetris</title>
<style>
body {
  margin:0;
  display:flex;
  justify-content:center;
  align-items:center;
  height:100vh;
  background: linear-gradient(120deg,#0f0f0f,#1a1a1a);
  font-family:sans-serif;
  color:#fff;
  overflow:hidden;
}

#tetrisContainer {
  display:flex;
  flex-direction: row;
  gap:20px;
  background: rgba(0,0,0,0.3);
  padding: 20px;
  border-radius: 16px;
  box-shadow: 0 8px 32px rgba(0,255,255,0.3);
  backdrop-filter: blur(8px);
}

canvas { 
  background:#222; 
  display:block; 
  border:1px solid #0ff; 
  border-radius:8px; 
  box-shadow: 0 0 20px #0ff;
}

#info {
  display:flex;
  flex-direction: column;
  font-size:16px;
  gap:10px;
}

#info div{
  background: rgba(0,0,0,0.5); 
  padding: 8px 12px; 
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.1);
}

#nextCanvas{
  background:#222;
  border-radius: 6px;
}
</style>
</head>
<body>
<div id="tetrisContainer">
  <canvas id="tetris" width="240" height="400"></canvas>
  <div id="info">
    <div id="score">Score: 0</div>
    <div id="level">Level: 1</div>
    <div id="speed">Speed: 0</div>
    <div>Next:</div>
    <canvas id="nextCanvas" width="80" height="80"></canvas>
  </div>
</div>

<script>
const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');
ctx.scale(20,20);

const nextCanvas = document.getElementById('nextCanvas');
const nctx = nextCanvas.getContext('2d');
nctx.scale(10,10);

const arenaWidth = 12, arenaHeight = 20;

function createMatrix(w,h){const m=[];while(h--) m.push(new Array(w).fill(0)); return m;}
function createPiece(type){
  if(type==='T') return [[0,0,0],[1,1,1],[0,1,0]];
  if(type==='O') return [[2,2],[2,2]];
  if(type==='L') return [[0,0,3],[3,3,3],[0,0,0]];
  if(type==='J') return [[4,0,0],[4,4,4],[0,0,0]];
  if(type==='I') return [[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]];
  if(type==='S') return [[0,6,6],[6,6,0],[0,0,0]];
  if(type==='Z') return [[7,7,0],[0,7,7],[0,0,0]];
}

const colors=[null,'#FF6B6B','#4EE29E','#4C88FF','#FFD74C','#FF7BFF','#4CE0E0','#B84CFF'];
let arena = createMatrix(arenaWidth,arenaHeight);

let dropCounter = 0, dropInterval = 1000, lastTime = 0;
let score = 0, level = 1;
let fastDrop = false, paused = false;
let flashRows = [], flashTimer = 0;
let gameOver = false;

const pieces = 'ILJOTSZ';
const player = {pos:{x:0,y:0}, matrix:null};
let nextPiece = createPiece(pieces[Math.floor(Math.random()*pieces.length)]);

function collide(arena,player){
  const m=player.matrix,o=player.pos;
  for(let y=0;y<m.length;y++)
    for(let x=0;x<m[y].length;x++)
      if(m[y][x]!==0 && (arena[y+o.y] && arena[y+o.y][x+o.x])!==0) return true;
  return false;
}

function merge(arena,player){
  player.matrix.forEach((row,y)=>row.forEach((v,x)=>{if(v!==0)arena[y+player.pos.y][x+player.pos.x]=v;}));
}

function rotate(matrix,dir){
  for(let y=0;y<matrix.length;y++)
    for(let x=y;x<matrix[y].length;x++)
      [matrix[x][y],matrix[y][x]]=[matrix[y][x],matrix[x][y]];
  if(dir>0) matrix.forEach(r=>r.reverse()); else matrix.reverse();
}

function playerReset(){
  player.matrix = nextPiece;
  player.pos.y = 0;
  player.pos.x = (arenaWidth/2|0)-(player.matrix[0].length/2|0);
  nextPiece = createPiece(pieces[Math.floor(Math.random()*pieces.length)]);
  updateNext();
  if(collide(arena,player)){
    gameOver = true;
  }
}

function getFilledRows(){
  let rows=[];
  outer: for(let y=arena.length-1;y>=0;y--){
    for(let x=0;x<arena[y].length;x++) if(arena[y][x]===0) continue outer;
    rows.push(y);
  }
  return rows;
}

function playerSweep(){
  const filled = getFilledRows();
  if(filled.length>0){
    flashRows = filled;
    flashTimer=0;
  }
}

function finalizeRows(){
  flashRows.sort((a,b)=>b-a);
  for(const y of flashRows){
    arena.splice(y,1);
    arena.unshift(new Array(arenaWidth).fill(0));
    score+=10;
  }
  flashRows=[];
  updateScore();
  level=Math.floor(score/100)+1;
  updateLevel();
  updateSpeed();
}

function playerDrop(){
  player.pos.y++;
  if(collide(arena,player)){
    player.pos.y--;
    merge(arena,player);
    playerSweep();
    playerReset();
  }
  dropCounter=0;
}

function playerMove(dir){
  player.pos.x+=dir;
  if(collide(arena,player)) player.pos.x-=dir;
}

function playerRotate(dir){
  const pos = player.pos.x;
  rotate(player.matrix,dir);
  let offset=1;
  while(collide(arena,player)){
    player.pos.x+=offset;
    offset=-(offset+(offset>0?1:-1));
    if(offset>player.matrix[0].length){rotate(player.matrix,-dir); player.pos.x=pos; return;}
  }
}

function drawMatrix(matrix,offset,context){
  const shakeAmount = fastDrop ? 0.2 : 0;
  matrix.forEach((row,y)=>row.forEach((v,x)=>{
    if(v!==0){
      let tx=x+offset.x + (Math.random()*shakeAmount*2 - shakeAmount);
      let ty=y+offset.y + (Math.random()*shakeAmount*2 - shakeAmount);
      context.fillStyle = colors[v];
      context.fillRect(tx,ty,1,1);
      context.strokeStyle="#111"; 
      context.lineWidth=0.05;
      context.strokeRect(tx,ty,1,1);
    }
  }));
}

function drawBackground(){
  ctx.fillStyle="#111";
  ctx.fillRect(0,0,arenaWidth,arenaHeight);
  ctx.strokeStyle="rgba(255,255,255,0.05)";
  ctx.lineWidth=0.02;
  for(let y=0;y<arenaHeight;y++){
    for(let x=0;x<arenaWidth;x++){
      ctx.strokeRect(x,y,1,1);
    }
  }
}

function draw(){
  drawBackground();
  ctx.save();
  if(fastDrop){
    const shake = Math.random()*0.2-0.1;
    ctx.translate(shake, shake);
  }

  ctx.strokeStyle="#0ff"; ctx.lineWidth=0.05; ctx.strokeRect(0,0,arenaWidth,arenaHeight);
  drawMatrix(arena,{x:0,y:0},ctx);
  drawMatrix(player.matrix,player.pos,ctx);
  ctx.restore();

  if(flashRows.length>0){
    flashTimer++;
    const visible=Math.floor(flashTimer/30)%2===0;
    if(visible){
      flashRows.forEach(y=>{
        ctx.fillStyle="rgba(255,255,255,0.7)";
        ctx.fillRect(0,y,arenaWidth,1);
      });
    }
    if(flashTimer>60){ finalizeRows(); flashTimer=0; }
  }

  if(paused && !gameOver){
    ctx.fillStyle="rgba(0,0,0,0.5)";
    ctx.fillRect(0,0,arenaWidth,arenaHeight);
    ctx.fillStyle="#0ff";
    ctx.font="1px sans-serif";
    ctx.textAlign="center";
    ctx.fillText("PAUSE",arenaWidth/2,arenaHeight/2);
  }

  if(gameOver){
    ctx.fillStyle="rgba(0,0,0,0.7)";
    ctx.fillRect(0,0,arenaWidth,arenaHeight);
    ctx.fillStyle="#FF4C4C";
    ctx.font="1px sans-serif";
    ctx.textAlign="center";
    ctx.fillText("GAME OVER",arenaWidth/2,arenaHeight/2-0.5);
    ctx.fillStyle="#0ff";
    ctx.font="0.5px sans-serif";
    ctx.fillText("Press R to Restart",arenaWidth/2,arenaHeight/2+0.5);
  }
}

function update(time=0){
  if(!paused && !gameOver){
    const deltaTime = time-lastTime;
    lastTime=time;
    dropCounter+=deltaTime;
    if(dropCounter>dropInterval/level) playerDrop();
  }
  draw();
  requestAnimationFrame(update);
}

function updateScore(){document.getElementById('score').innerText='Score: '+score;}
function updateLevel(){document.getElementById('level').innerText='Level: '+level;}
function updateSpeed(){document.getElementById('speed').innerText='Speed: '+Math.floor(dropInterval/level);}

function updateNext(){
  nctx.fillStyle="#222"; nctx.fillRect(0,0,nextCanvas.width,nextCanvas.height);
  const offset={x:Math.floor((nextCanvas.width/10 - nextPiece[0].length)/2),y:Math.floor((nextCanvas.height/10 - nextPiece.length)/2)};
  drawMatrix(nextPiece,offset,nctx);
}

document.addEventListener('keydown',e=>{
  if(['ArrowLeft','ArrowRight','ArrowDown','ArrowUp',' '].includes(e.key)) e.preventDefault();

  if(gameOver && e.key==='r'){ 
    arena = createMatrix(arenaWidth,arenaHeight);
    score=0; level=1; updateScore(); updateLevel(); updateSpeed();
    gameOver=false; playerReset(); return;
  }

  if(paused && !gameOver && e.key!=='Escape') return;

  if(e.key==='ArrowLeft') playerMove(-1);
  else if(e.key==='ArrowRight') playerMove(1);
  else if(e.key==='ArrowDown') playerDrop();
  else if(e.key==='ArrowUp') playerRotate(1);
  else if(e.key===' '){
    fastDrop=true;
    while(!collide(arena,player)) player.pos.y++;
    player.pos.y--; merge(arena,player); playerSweep(); playerReset();
    fastDrop=false;
  }
  else if(e.key==='Escape') paused=!paused;
});

playerReset(); updateScore(); updateLevel(); updateSpeed();
update();
</script>
</body>
</html>
